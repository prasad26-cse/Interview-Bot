# AI Video Interviewer (VidHire)

VidHire is an intelligent, AI-powered platform designed to streamline and enhance the technical interview process. It automates key parts of the hiring workflow, from generating relevant questions to evaluating candidate responses, allowing recruiters and hiring managers to focus on finding the best talent.

## Core Features

- **Role-Aware AI Greeting**: A warm, role-specific greeting is dynamically generated by AI to create a welcoming experience for the candidate.
- **Dynamic Question Generation**: The platform generates 5-7 tailored interview questions based on the job role and description, covering a range of topics from technical to behavioral with a difficulty gradient.
- **In-Browser Video Recording**: Candidates can record, review, and re-record their video answers directly in the browser, providing a seamless user experience.
- **AI-Powered Transcription**: Video responses are automatically transcribed with high accuracy using an AI service.
- **Comprehensive AI Evaluation**: Candidate responses are analyzed by an AI model to provide:
    - A concise summary of the candidate's performance.
    - A list of identified strengths and weaknesses.
    - A 1-5 rating across key skills like communication, technical depth, and problem-solving.
    - An overall score.
- **Interactive Recruiter Dashboard**: A dedicated console for recruiters to:
    - Filter and view all submitted interviews.
    - Watch video responses, read transcripts, and review the AI evaluation in an expandable, all-in-one view.
    - Access a detailed, full-page report for each candidate.
- **Dual Authentication System**: Separate, secure login and signup flows for both candidates and recruiters.

## Tech Stack

This project is built with a modern, performant, and type-safe technology stack:

- **Framework**: [Next.js](https://nextjs.org/) (App Router)
- **UI Library**: [React](https://react.dev/)
- **Language**: [TypeScript](https://www.typescriptlang.org/)
- **Styling**: [Tailwind CSS](https://tailwindcss.com/) with [ShadCN UI](https://ui.shadcn.com/) for components
- **AI Integration**: [Google's Genkit](https://firebase.google.com/docs/genkit) for all generative AI flows (greetings, questions, transcription, evaluation).
- **Database ORM**: [Prisma](https://www.prisma.io/) (pre-configured for easy connection to a permanent database).

## Getting Started

Follow these steps to get the project running on your local machine.

### Prerequisites

- [Node.js](https://nodejs.org/en) (v18 or later recommended)
- [npm](https://www.npmjs.com/) or a compatible package manager

### 1. Installation

Clone the repository and install the dependencies.

```bash
git clone <repository-url>
cd <repository-name>
npm install
```

### 2. Set Up Environment Variables

The project uses Google's Genkit for its AI features. You will need a Google AI API key.

1.  Create a `.env` file in the root of the project by copying the example:
    ```bash
    cp .env.example .env
    ```
2.  Visit the [Google AI Studio](https://aistudio.google.com/app/apikey) to generate an API key.
3.  Add your API key to the `.env` file:
    ```
    GEMINI_API_KEY=your_api_key_here
    ```

### 3. Run the Development Servers

This project requires two concurrent development servers: one for the Next.js application and one for the Genkit AI flows.

-   **Start the Next.js app:**
    ```bash
    npm run dev
    ```
    The application will be available at `http://localhost:9002`.

-   **Start the Genkit server (in a separate terminal):**
    ```bash
    npm run genkit:watch
    ```
    This starts the Genkit development server, which hot-reloads when you make changes to the AI flows in `src/ai/flows/`.

## Transitioning to a Permanent Database

The project is pre-configured to use [Prisma](https://www.prisma.io/), making it easy to switch from the temporary mock data to a permanent database like PostgreSQL or MySQL.

### Steps:

1.  **Choose a Database**: Set up a database instance (e.g., on Vercel, Supabase, AWS RDS, or a local server) and get its connection string.

2.  **Update Prisma Schema**: Open `prisma/schema.prisma`. The `provider` in the `datasource` block is currently set to `postgresql`. Change it to `mysql` or another supported database if needed.

3.  **Add Database URL to `.env`**: Add your database connection string to the `.env` file.
    ```
    DATABASE_URL="your_database_connection_string_here"
    ```

4.  **Generate Prisma Client**: Generate the Prisma client code based on your schema.
    ```bash
    npx prisma generate
    ```

5.  **Sync Database Schema**: Push the schema to your database. This will create all the necessary tables.
    ```bash
    npx prisma db push
    ```

6.  **Update Server Actions**: Modify the data-fetching and mutation logic in `src/lib/actions.ts`. Replace the mock data array manipulations (e.g., `interviews.unshift(...)`) with Prisma Client queries (e.g., `await prisma.interview.create(...)`). The file contains `DEV NOTE` comments pointing to exactly where these changes are needed.

## Project Structure

```
.
├── prisma/             # Prisma schema for database models
├── public/             # Static assets
└── src/
    ├── ai/             # Genkit AI configuration and flows
    ├── app/            # Next.js App Router pages and layouts
    ├── components/     # Reusable React components, including ShadCN UI
    ├── hooks/          # Custom React hooks
    ├── lib/            # Core libraries, actions, types, and mock data
    └── ...
```

This clear structure separates concerns, making the application easy to maintain and scale.
